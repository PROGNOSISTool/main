# Learning QUIC

Created By: Tiago Ferreira
Last Edited: Jul 13, 2020 3:27 PM

- Intro to TCP
    - Every packet has 2 types of state: Connection fixed state, and connection dynamic state. IPs and Port Numbers are connection fixed. Flags, SEQ and ACK numbers are connection dynamic.
    - With just flags, SEQ and ACK numbers we can make the vast majority of TCP packets, valid or invalid.
    - There is no cryptography involved so forging any packet and injecting it into a connection is not complicated.
- Learning TCP
    - Even TCP cannot be fully represented by a Mealy Machine, so there are some restrictions imposed. Namely, the alphabet includes only a minimal number of flag combinations, payload is limited to 0 or 1 byte, and SEQ and ACK numbers are abstracted using a mapper. All more niche fields are disabled if possible, or set to their defaults.
    - With TCP learning there are 4 main components: The learner, the abstraction component (mapper), the adapters, and the SUL.
    - The learner is Java based, and makes use of LearnLib.
    - The Abstraction Component, or mapper, is responsible for converting between abstract input/outputs and concrete input/outputs. Do note that a concrete input/output is not yet a TCP packet. It simply converts say `SYN(VALID,VALID,0)` into `SYN(123, 12, nil)`, i.e. adds the appropriate dynamic state. The abstraction component is made with a custom undocumented library and programming language.
    - The adapter is responsible for, on receipt of a concrete input, building the packet requested, sending it over the wire, and capturing any packets received back. It then interprets the packets as concrete outputs, and sends them back to the mapper to be abstracted. In this case the adapter is Scapy based. Scapy is a python library that has implementations of common protocols, one of them being TCP. Scapy is used to, on receipt of a string like `SYN(123, 12, nil)`, creating a TCP packet that indeed has a SYN flag, the SEQ number 123, the ACK number 12, and no payload, no matter how valid or invalid that might be, and sending it over. Immediately after, the adapter makes use of pcap to capture any received packets and turn them into concrete outputs. The adapter is thus completely stateless. It simply fills in a packet with the exact instructions of the mapper.
    - The SUL is a TCP implementation that we control. And this is because it needs to be an implementation where delayed ACKs are disabled. Delayed ACKs try to optimise packets by buffering and bundling ACKs together rather than sending them immediately. This isn't wanted for our case as it introduces time dependent behaviour.
    - Intro to QUIC
        - In this case when we say QUIC we mean FIET's QUIC, draft version 29 (the latest).
        - QUIC is the fruit of the thought "The OSI model provides great modularity and isolation, however 90% of internet traffic uses the same layers. HTTP/TLS/TCP/IP. What if we made a protocol that combines most of the features of that entire stack, thus making it more efficient and secure?"
        - For the sake of simplicity one can treat QUIC as the union of UDP, TLS, some aspects of TCP and even some aspects of NAT.
        - As you can imagine this means that everything QUIC, from packets to connections is quite more complex than with a "single layer protocol" like TCP.
        - QUIC packets are carried over UDP. This is to ensure that middle boxes that aren't aware of the protocol can treat it just like any other UDP payload, and send it on its way.
        - The main structure of QUIC datagrams can be described as follows: An UDP packet can carry one or more QUIC packets. QUIC packets can have different types with different header formats, they cary one or more QUIC frames. Each QUIC frame has its own type and format. Some may even have complex payloads like app data or TLS data.
        - The main reason for having different packet types is the need for different levels of cryptography. Some packets might have no crypto whatsoever because they happen before a version is even negotiated, some might have only signed payloads as that's what the keys allow for, some might be fully encrypted after handshake. Each of these different packet types coexist in the same connection, and they have separate packet number counters, separate ACKs and even separate retransmission rules.
        - Different packets also have different dynamic state. While with TCP we only have flags, SEQ and ACK numbers, with QUIC we have packet numbers, version identifiers, header forms, packet types, destination connection ID, DCID length, Source connection ID, SCID length, and state that is enclosed in the frames themselves, like key derivation, exchange, and storage.
    - Learning QUIC
        - We start by attempting to adapt the TCP learner to learn QUIC. Namely, let's look at the changes and potential issues with each component.
        - The learner can be easily adapted, as it is abstract by nature. It's mostly a matter of adapting the symbols to represent QUIC, and the oracles to communicate with the new mapper and adapter.
        - The mapper would have to be heavily modified, this is a problem I haven't solved yet. The mapper used by TCP is built for purpose, and uses a very minimal programming language to generate the mealy machine that controls state. Unfortunately state in QUIC is quite advanced, requiring operations like key derivation, encryption, decryption, and not just counters.
        - The adapter also had to be rebuilt from scratch, as Scapy does not support QUIC.
            - There is an option to implement new protocols in Scapy, and this has been attempted before for QUIC learning, however with little success.
            - This is mostly due to cryptography libs in python in general not satisfying the cipher requirements of QUIC.
            - I have overcome this issue by making use of a minimal QUIC implementation called "QUIC Toolbox", from the "QUIC Tracker" project, that was initially developed to be used for conformance testing of QUIC, and so is extremely modular. I've had significant success modifying it to be an adapter and send and receive arbitrary packets, when technically possible.
            - I say technically possible, because even though we might want to send what we deem are "invalid packets", i.e. packets that do not conform to the protocol specification, some of those instances might not be technically possible, like sending an encrypted  packet before any handshake takes place to receive the keys needed for encryption. QUIC calls these "Encryption Levels". I have handled this by letting the adapter choose not to send a packet when not technically possible under the current Max Encryption Level, and registering the timeout received caused by nothing being sent.
        - The implementation has to be an implementation that we control, and not just any accessible endpoint, this is for the same reason as in learning TCP, we want to disable ACK delay, to reduce time dependent behaviour. This is an option that is implemented in QUIC, but is by default off, so we need to run our own server where that disable flag is on. I believe this might not be enough, as the "buffering and delaying" technique TCP uses for ACKs is adopted in general by all frames when possible, however I'll need to do more research on this.